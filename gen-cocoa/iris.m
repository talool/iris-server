/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"


#import "iris.h"

@implementation IrisException_t

- (id) init
{
  return [super initWithName: @"IrisException_t" reason: @"unknown" userInfo: nil];
}

- (id) initWithErrorCode: (int32_t) errorCode errorDesc: (NSString *) errorDesc
{
  self = [self init];
  __errorCode = errorCode;
  __errorCode_isset = YES;
  __errorDesc = [errorDesc retain_stub];
  __errorDesc_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super initWithCoder: decoder];
  if ([decoder containsValueForKey: @"errorCode"])
  {
    __errorCode = [decoder decodeInt32ForKey: @"errorCode"];
    __errorCode_isset = YES;
  }
  if ([decoder containsValueForKey: @"errorDesc"])
  {
    __errorDesc = [[decoder decodeObjectForKey: @"errorDesc"] retain_stub];
    __errorDesc_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  [super encodeWithCoder: encoder];
  if (__errorCode_isset)
  {
    [encoder encodeInt32: __errorCode forKey: @"errorCode"];
  }
  if (__errorDesc_isset)
  {
    [encoder encodeObject: __errorDesc forKey: @"errorDesc"];
  }
}

- (void) dealloc
{
  [__errorDesc release_stub];
  [super dealloc_stub];
}

- (int32_t) errorCode {
  return __errorCode;
}

- (void) setErrorCode: (int32_t) errorCode {
  __errorCode = errorCode;
  __errorCode_isset = YES;
}

- (BOOL) errorCodeIsSet {
  return __errorCode_isset;
}

- (void) unsetErrorCode {
  __errorCode_isset = NO;
}

- (NSString *) errorDesc {
  return [[__errorDesc retain_stub] autorelease_stub];
}

- (void) setErrorDesc: (NSString *) errorDesc {
  [errorDesc retain_stub];
  [__errorDesc release_stub];
  __errorDesc = errorDesc;
  __errorDesc_isset = YES;
}

- (BOOL) errorDescIsSet {
  return __errorDesc_isset;
}

- (void) unsetErrorDesc {
  [__errorDesc release_stub];
  __errorDesc = nil;
  __errorDesc_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setErrorCode: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setErrorDesc: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"IrisException_t"];
  if (__errorCode_isset) {
    [outProtocol writeFieldBeginWithName: @"errorCode" type: TType_I32 fieldID: 1];
    [outProtocol writeI32: __errorCode];
    [outProtocol writeFieldEnd];
  }
  if (__errorDesc_isset) {
    if (__errorDesc != nil) {
      [outProtocol writeFieldBeginWithName: @"errorDesc" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __errorDesc];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"IrisException_t("];
  [ms appendString: @"errorCode:"];
  [ms appendFormat: @"%i", __errorCode];
  [ms appendString: @",errorDesc:"];
  [ms appendFormat: @"\"%@\"", __errorDesc];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Location_t

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithLongitude: (double) longitude latitude: (double) latitude
{
  self = [super init];
  __longitude = longitude;
  __longitude_isset = YES;
  __latitude = latitude;
  __latitude_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"longitude"])
  {
    __longitude = [decoder decodeDoubleForKey: @"longitude"];
    __longitude_isset = YES;
  }
  if ([decoder containsValueForKey: @"latitude"])
  {
    __latitude = [decoder decodeDoubleForKey: @"latitude"];
    __latitude_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__longitude_isset)
  {
    [encoder encodeDouble: __longitude forKey: @"longitude"];
  }
  if (__latitude_isset)
  {
    [encoder encodeDouble: __latitude forKey: @"latitude"];
  }
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (double) longitude {
  return __longitude;
}

- (void) setLongitude: (double) longitude {
  __longitude = longitude;
  __longitude_isset = YES;
}

- (BOOL) longitudeIsSet {
  return __longitude_isset;
}

- (void) unsetLongitude {
  __longitude_isset = NO;
}

- (double) latitude {
  return __latitude;
}

- (void) setLatitude: (double) latitude {
  __latitude = latitude;
  __latitude_isset = YES;
}

- (BOOL) latitudeIsSet {
  return __latitude_isset;
}

- (void) unsetLatitude {
  __latitude_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_DOUBLE) {
          double fieldValue = [inProtocol readDouble];
          [self setLongitude: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_DOUBLE) {
          double fieldValue = [inProtocol readDouble];
          [self setLatitude: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Location_t"];
  if (__longitude_isset) {
    [outProtocol writeFieldBeginWithName: @"longitude" type: TType_DOUBLE fieldID: 1];
    [outProtocol writeDouble: __longitude];
    [outProtocol writeFieldEnd];
  }
  if (__latitude_isset) {
    [outProtocol writeFieldBeginWithName: @"latitude" type: TType_DOUBLE fieldID: 2];
    [outProtocol writeDouble: __latitude];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Location_t("];
  [ms appendString: @"longitude:"];
  [ms appendFormat: @"%f", __longitude];
  [ms appendString: @",latitude:"];
  [ms appendFormat: @"%f", __latitude];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation CustomerMetadata_t

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithCustomerId: (NSString *) customerId deviceId: (NSString *) deviceId email: (NSString *) email ipAddress: (NSString *) ipAddress location: (Location_t *) location
{
  self = [super init];
  __customerId = [customerId retain_stub];
  __customerId_isset = YES;
  __deviceId = [deviceId retain_stub];
  __deviceId_isset = YES;
  __email = [email retain_stub];
  __email_isset = YES;
  __ipAddress = [ipAddress retain_stub];
  __ipAddress_isset = YES;
  __location = [location retain_stub];
  __location_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"customerId"])
  {
    __customerId = [[decoder decodeObjectForKey: @"customerId"] retain_stub];
    __customerId_isset = YES;
  }
  if ([decoder containsValueForKey: @"deviceId"])
  {
    __deviceId = [[decoder decodeObjectForKey: @"deviceId"] retain_stub];
    __deviceId_isset = YES;
  }
  if ([decoder containsValueForKey: @"email"])
  {
    __email = [[decoder decodeObjectForKey: @"email"] retain_stub];
    __email_isset = YES;
  }
  if ([decoder containsValueForKey: @"ipAddress"])
  {
    __ipAddress = [[decoder decodeObjectForKey: @"ipAddress"] retain_stub];
    __ipAddress_isset = YES;
  }
  if ([decoder containsValueForKey: @"location"])
  {
    __location = [[decoder decodeObjectForKey: @"location"] retain_stub];
    __location_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__customerId_isset)
  {
    [encoder encodeObject: __customerId forKey: @"customerId"];
  }
  if (__deviceId_isset)
  {
    [encoder encodeObject: __deviceId forKey: @"deviceId"];
  }
  if (__email_isset)
  {
    [encoder encodeObject: __email forKey: @"email"];
  }
  if (__ipAddress_isset)
  {
    [encoder encodeObject: __ipAddress forKey: @"ipAddress"];
  }
  if (__location_isset)
  {
    [encoder encodeObject: __location forKey: @"location"];
  }
}

- (void) dealloc
{
  [__customerId release_stub];
  [__deviceId release_stub];
  [__email release_stub];
  [__ipAddress release_stub];
  [__location release_stub];
  [super dealloc_stub];
}

- (NSString *) customerId {
  return [[__customerId retain_stub] autorelease_stub];
}

- (void) setCustomerId: (NSString *) customerId {
  [customerId retain_stub];
  [__customerId release_stub];
  __customerId = customerId;
  __customerId_isset = YES;
}

- (BOOL) customerIdIsSet {
  return __customerId_isset;
}

- (void) unsetCustomerId {
  [__customerId release_stub];
  __customerId = nil;
  __customerId_isset = NO;
}

- (NSString *) deviceId {
  return [[__deviceId retain_stub] autorelease_stub];
}

- (void) setDeviceId: (NSString *) deviceId {
  [deviceId retain_stub];
  [__deviceId release_stub];
  __deviceId = deviceId;
  __deviceId_isset = YES;
}

- (BOOL) deviceIdIsSet {
  return __deviceId_isset;
}

- (void) unsetDeviceId {
  [__deviceId release_stub];
  __deviceId = nil;
  __deviceId_isset = NO;
}

- (NSString *) email {
  return [[__email retain_stub] autorelease_stub];
}

- (void) setEmail: (NSString *) email {
  [email retain_stub];
  [__email release_stub];
  __email = email;
  __email_isset = YES;
}

- (BOOL) emailIsSet {
  return __email_isset;
}

- (void) unsetEmail {
  [__email release_stub];
  __email = nil;
  __email_isset = NO;
}

- (NSString *) ipAddress {
  return [[__ipAddress retain_stub] autorelease_stub];
}

- (void) setIpAddress: (NSString *) ipAddress {
  [ipAddress retain_stub];
  [__ipAddress release_stub];
  __ipAddress = ipAddress;
  __ipAddress_isset = YES;
}

- (BOOL) ipAddressIsSet {
  return __ipAddress_isset;
}

- (void) unsetIpAddress {
  [__ipAddress release_stub];
  __ipAddress = nil;
  __ipAddress_isset = NO;
}

- (Location_t *) location {
  return [[__location retain_stub] autorelease_stub];
}

- (void) setLocation: (Location_t *) location {
  [location retain_stub];
  [__location release_stub];
  __location = location;
  __location_isset = YES;
}

- (BOOL) locationIsSet {
  return __location_isset;
}

- (void) unsetLocation {
  [__location release_stub];
  __location = nil;
  __location_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setCustomerId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setDeviceId: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setEmail: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setIpAddress: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_STRUCT) {
          Location_t *fieldValue = [[Location_t alloc] init];
          [fieldValue read: inProtocol];
          [self setLocation: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"CustomerMetadata_t"];
  if (__customerId_isset) {
    if (__customerId != nil) {
      [outProtocol writeFieldBeginWithName: @"customerId" type: TType_STRING fieldID: 1];
      [outProtocol writeString: __customerId];
      [outProtocol writeFieldEnd];
    }
  }
  if (__deviceId_isset) {
    if (__deviceId != nil) {
      [outProtocol writeFieldBeginWithName: @"deviceId" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __deviceId];
      [outProtocol writeFieldEnd];
    }
  }
  if (__email_isset) {
    if (__email != nil) {
      [outProtocol writeFieldBeginWithName: @"email" type: TType_STRING fieldID: 3];
      [outProtocol writeString: __email];
      [outProtocol writeFieldEnd];
    }
  }
  if (__ipAddress_isset) {
    if (__ipAddress != nil) {
      [outProtocol writeFieldBeginWithName: @"ipAddress" type: TType_STRING fieldID: 4];
      [outProtocol writeString: __ipAddress];
      [outProtocol writeFieldEnd];
    }
  }
  if (__location_isset) {
    if (__location != nil) {
      [outProtocol writeFieldBeginWithName: @"location" type: TType_STRUCT fieldID: 5];
      [__location write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"CustomerMetadata_t("];
  [ms appendString: @"customerId:"];
  [ms appendFormat: @"\"%@\"", __customerId];
  [ms appendString: @",deviceId:"];
  [ms appendFormat: @"\"%@\"", __deviceId];
  [ms appendString: @",email:"];
  [ms appendFormat: @"\"%@\"", __email];
  [ms appendString: @",ipAddress:"];
  [ms appendFormat: @"\"%@\"", __ipAddress];
  [ms appendString: @",location:"];
  [ms appendFormat: @"%@", __location];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end


@implementation irisConstants
+ (void) initialize {
}
@end

@interface getNotificationMessages_args : NSObject <NSCoding> {
  CustomerMetadata_t * __customerMetadata;

  BOOL __customerMetadata_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=customerMetadata, setter=setCustomerMetadata:) CustomerMetadata_t * customerMetadata;
#endif

- (id) init;
- (id) initWithCustomerMetadata: (CustomerMetadata_t *) customerMetadata;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (CustomerMetadata_t *) customerMetadata;
- (void) setCustomerMetadata: (CustomerMetadata_t *) customerMetadata;
#endif
- (BOOL) customerMetadataIsSet;

@end

@implementation getNotificationMessages_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithCustomerMetadata: (CustomerMetadata_t *) customerMetadata
{
  self = [super init];
  __customerMetadata = [customerMetadata retain_stub];
  __customerMetadata_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"customerMetadata"])
  {
    __customerMetadata = [[decoder decodeObjectForKey: @"customerMetadata"] retain_stub];
    __customerMetadata_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__customerMetadata_isset)
  {
    [encoder encodeObject: __customerMetadata forKey: @"customerMetadata"];
  }
}

- (void) dealloc
{
  [__customerMetadata release_stub];
  [super dealloc_stub];
}

- (CustomerMetadata_t *) customerMetadata {
  return [[__customerMetadata retain_stub] autorelease_stub];
}

- (void) setCustomerMetadata: (CustomerMetadata_t *) customerMetadata {
  [customerMetadata retain_stub];
  [__customerMetadata release_stub];
  __customerMetadata = customerMetadata;
  __customerMetadata_isset = YES;
}

- (BOOL) customerMetadataIsSet {
  return __customerMetadata_isset;
}

- (void) unsetCustomerMetadata {
  [__customerMetadata release_stub];
  __customerMetadata = nil;
  __customerMetadata_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          CustomerMetadata_t *fieldValue = [[CustomerMetadata_t alloc] init];
          [fieldValue read: inProtocol];
          [self setCustomerMetadata: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"getNotificationMessages_args"];
  if (__customerMetadata_isset) {
    if (__customerMetadata != nil) {
      [outProtocol writeFieldBeginWithName: @"customerMetadata" type: TType_STRUCT fieldID: 1];
      [__customerMetadata write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"getNotificationMessages_args("];
  [ms appendString: @"customerMetadata:"];
  [ms appendFormat: @"%@", __customerMetadata];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface GetNotificationMessages_result : NSObject <NSCoding> {
  IrisException_t * __error;

  BOOL __error_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=error, setter=setError:) IrisException_t * error;
#endif

- (id) init;
- (id) initWithError: (IrisException_t *) error;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

#if !__has_feature(objc_arc)
- (IrisException_t *) error;
- (void) setError: (IrisException_t *) error;
#endif
- (BOOL) errorIsSet;

@end

@implementation GetNotificationMessages_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithError: (IrisException_t *) error
{
  self = [super init];
  __error = [error retain_stub];
  __error_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"error"])
  {
    __error = [[decoder decodeObjectForKey: @"error"] retain_stub];
    __error_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__error_isset)
  {
    [encoder encodeObject: __error forKey: @"error"];
  }
}

- (void) dealloc
{
  [__error release_stub];
  [super dealloc_stub];
}

- (IrisException_t *) error {
  return [[__error retain_stub] autorelease_stub];
}

- (void) setError: (IrisException_t *) error {
  [error retain_stub];
  [__error release_stub];
  __error = error;
  __error_isset = YES;
}

- (BOOL) errorIsSet {
  return __error_isset;
}

- (void) unsetError {
  [__error release_stub];
  __error = nil;
  __error_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          IrisException_t *fieldValue = [[IrisException_t alloc] init];
          [fieldValue read: inProtocol];
          [self setError: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"GetNotificationMessages_result"];

  if (__error_isset) {
    if (__error != nil) {
      [outProtocol writeFieldBeginWithName: @"error" type: TType_STRUCT fieldID: 1];
      [__error write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"GetNotificationMessages_result("];
  [ms appendString: @"error:"];
  [ms appendFormat: @"%@", __error];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation Iris_tClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) dealloc
{
  [inProtocol release_stub];
  [outProtocol release_stub];
  [super dealloc_stub];
}

- (void) send_getNotificationMessages: (CustomerMetadata_t *) customerMetadata
{
  [outProtocol writeMessageBeginWithName: @"getNotificationMessages" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"getNotificationMessages_args"];
  if (customerMetadata != nil)  {
    [outProtocol writeFieldBeginWithName: @"customerMetadata" type: TType_STRUCT fieldID: 1];
    [customerMetadata write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
}

- (void) recv_getNotificationMessages
{
  int msgType = 0;
  [inProtocol readMessageBeginReturningName: nil type: &msgType sequenceID: NULL];
  if (msgType == TMessageType_EXCEPTION) {
    TApplicationException * x = [TApplicationException read: inProtocol];
    [inProtocol readMessageEnd];
    @throw x;
  }
  GetNotificationMessages_result * result = [[[GetNotificationMessages_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result errorIsSet]) {
    @throw [result error];
  }
  return;
}

- (void) getNotificationMessages: (CustomerMetadata_t *) customerMetadata
{
  [self send_getNotificationMessages : customerMetadata];
  [self recv_getNotificationMessages];
}

@end

@implementation Iris_tProcessor

- (id) initWithIris_t: (id <Iris_t>) service
{
  self = [super init];
  if (!self) {
    return nil;
  }
  mService = [service retain_stub];
  mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
  {
    SEL s = @selector(process_getNotificationMessages_withSequenceID:inProtocol:outProtocol:);
    NSMethodSignature * sig = [self methodSignatureForSelector: s];
    NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
    [invocation setSelector: s];
    [invocation retainArguments];
    [mMethodMap setValue: invocation forKey: @"getNotificationMessages"];
  }
  return self;
}

- (id<Iris_t>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_getNotificationMessages_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
  getNotificationMessages_args * args = [[getNotificationMessages_args alloc] init];
  [args read: inProtocol];
  [inProtocol readMessageEnd];
  GetNotificationMessages_result * result = [[GetNotificationMessages_result alloc] init];
  [mService getNotificationMessages: [args customerMetadata]];
  [outProtocol writeMessageBeginWithName: @"getNotificationMessages"
                                    type: TMessageType_REPLY
                              sequenceID: seqID];
  [result write: outProtocol];
  [outProtocol writeMessageEnd];
  [[outProtocol transport] flush];
  [result release_stub];
  [args release_stub];
}

- (void) dealloc
{
  [mService release_stub];
  [mMethodMap release_stub];
  [super dealloc_stub];
}

@end

